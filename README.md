# OwinWebApi
Тестовое задание
Все требования выполнены, Swagger генерирует описание проекту (доступен по своему стандартному адресу {baseUrl}/swagger/ui/index), веб-сервис обрабатывает запросы параллельно.
Данные хранятся в оперативной памяти (естественно только в течении жизни приложения), урлы валидируются по необходимому формату
Основной (и единственный) контроллер - TestController, эндпоинты [Get] Terminate (пункт 1 из требований) [Post] IncremmentArray (пункт 2)
Примечания: 
 - Я не до конца уверен что я правильно понял пункт 1 (а я понял его как терминация всего приложения полностью при доступе к эндпоинту) - и моя имплементация далека от идеала, более подробный коментарий в LifeTimeManager.cs
 - В конкретной имплементации InMemoryRepository тот факт что мы используем асинхронные методы естественно не имеет большого смысла тк мы получаем доступ к единственному ресурсу внутри нашей же памяти и все, идея естественно в том что IRepository интерфейс будет использоватся для доступа в бд/кэш и тд
 - Использование RetryPolicy в InMemoryRepository тоже имеет мало смысла учитывая что мы стучимся сами себе в память, этот дизайн естественно куда лучше подходит для доступа во внешние ресурсы, плюс сам факт его использование по-хорошему должен быть в своем бизнес-слое, а не в репозитории, просто учитывая то что в настолько простой задаче бизнеса шибко нет - то пришлось пристроить куда-то.
 В имплементации самого ConcurrentDictionary мы в принципе используем бесконечный цикл, что имеет смысл в этом случае, но не люблю как данность оставлять возможность бесконечных циклов в своих эндпоинтах. Опять же, имей мы дело с внешним ресурсом - мы бы просто лочили этот ресурс и обрабатывали реквесты в очереди, но лочить весь словарь когда два разных потока со всей вероятностью пытаются получить доступ к разным индексам - не имеет большого смысла.
 - Использование словаря для хранения данных для пункта 2 (а не массива) обосновано очень просто - массив должен быть инициализирован с размером равным самому большому элементу что мы пытаемся добавить/получить. Инициализировать массив в 1000 элементов когда нам просто нужен элемент №1000 - немного бесмыссленно. Мы к сожалению не пишем на Haskell где аллокация бесконечного массива данных была бы бесплатной)

Время выполнения: в районе часа, может чуть больше, учитывая что внутри самой же задачи есть ссылка с готовым сетапом, за что спасибо) Пришлось немного почитать доки по самому Owin тк никогда не раскручивал веб-сервисы с него, да и с консоли в целом, но ничего такого фундаментально сложного. Ну и накидать бойлерплейт-код тоже занимает какое-то время, хоть это и чисто механическая задача.

Всякие доп вещи что естественно были бы частью серьезного API дизайна (как-то аутентификация например) опущены ввиду того что не были в требованиях, и просто для экономии времени)

Оригинальное описание задачи:
Необходимо создать консольное приложение, поднимающее собственный веб-сервис, способный принимать
множественные одновременные подключения по адресу (или адресам, перечисленным через символ ‘;’),
указанному в параметре запуска (например, http://localhost:9000;http://localhost:9090/dev/). Контроллер данного
REST-сервиса (желательно авто-генерация OpenAPI спецификации) должен поддерживать 2 метода:
1. Метод передачи команды выхода основному консольному приложению (далее – Базе). Возвращает
подтверждение, что команда Базой получена.
2. Метод с параметром номера элемента, строго последовательно инкрементирующий значение
данного элемента массива Базы.
Переносить данные в контроллер или получать их с помощью ORM/внешних источников данных запрещено.

Дополнительные материалы: можно (но не обязательно) использовать классическое решение от MS (Owin),
пакеты nuget, готовые решения в качестве шаблона с github и т.п. (например,
https://medium.com/@Rocco_Sen/how-to-create-a-c-console-application-and-configure-owin-to-host-webapi-
3f3e772666cf)
К решению составить описание, сколько времени потребовалось на реализацию, над чем сомневались,
почему остановились на таком решении, +/-, рассмотренные в процессе рассмотрения задачи, либо
необходимо быть готовым обосновать подход к решению в ходе беседы после пересылки результата.
Если задача кажется сложной, можете попробовать отказаться от ряда требований, но при этом необходимо
обосновать, почему решение будет более оптимальным без их реализации.
